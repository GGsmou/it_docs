<!DOCTYPE html><html lang="en" dir="ltr" data-has-toc data-has-sidebar data-theme="dark" class="astro-bguv2lll"> <head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Notes of "Code Complete 2nd edition" by Steve McConnel | IT Docs</title><link rel="canonical"/><link rel="shortcut icon" href="/it_docs/favicon.svg" type="image/svg+xml"/><meta name="generator" content="Astro v4.4.4"/><meta name="generator" content="Starlight v0.19.1"/><meta property="og:title" content="Notes of &#34;Code Complete 2nd edition&#34; by Steve McConnel"/><meta property="og:type" content="article"/><meta property="og:url"/><meta property="og:locale" content="en"/><meta property="og:description"/><meta property="og:site_name" content="IT Docs"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Notes of &#34;Code Complete 2nd edition&#34; by Steve McConnel"/><meta name="twitter:description"/><script>
	window.StarlightThemeProvider = (() => {
		const storedTheme =
			typeof localStorage !== 'undefined' && localStorage.getItem('starlight-theme');
		const theme =
			storedTheme ||
			(window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
		document.documentElement.dataset.theme = theme === 'light' ? 'light' : 'dark';
		return {
			updatePickers(theme = storedTheme || 'auto') {
				document.querySelectorAll('starlight-theme-select').forEach((picker) => {
					const select = picker.querySelector('select');
					if (select) select.value = theme;
					/** @type {HTMLTemplateElement | null} */
					const tmpl = document.querySelector(`#theme-icons`);
					const newIcon = tmpl && tmpl.content.querySelector('.' + theme);
					if (newIcon) {
						const oldIcon = picker.querySelector('svg.label-icon');
						if (oldIcon) {
							oldIcon.replaceChildren(...newIcon.cloneNode(true).childNodes);
						}
					}
				});
			},
		};
	})();
</script><template id="theme-icons"><svg aria-hidden="true" class="light astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M5 12a1 1 0 0 0-1-1H3a1 1 0 0 0 0 2h1a1 1 0 0 0 1-1Zm.64 5-.71.71a1 1 0 0 0 0 1.41 1 1 0 0 0 1.41 0l.71-.71A1 1 0 0 0 5.64 17ZM12 5a1 1 0 0 0 1-1V3a1 1 0 0 0-2 0v1a1 1 0 0 0 1 1Zm5.66 2.34a1 1 0 0 0 .7-.29l.71-.71a1 1 0 1 0-1.41-1.41l-.66.71a1 1 0 0 0 0 1.41 1 1 0 0 0 .66.29Zm-12-.29a1 1 0 0 0 1.41 0 1 1 0 0 0 0-1.41l-.71-.71a1.004 1.004 0 1 0-1.43 1.41l.73.71ZM21 11h-1a1 1 0 0 0 0 2h1a1 1 0 0 0 0-2Zm-2.64 6A1 1 0 0 0 17 18.36l.71.71a1 1 0 0 0 1.41 0 1 1 0 0 0 0-1.41l-.76-.66ZM12 6.5a5.5 5.5 0 1 0 5.5 5.5A5.51 5.51 0 0 0 12 6.5Zm0 9a3.5 3.5 0 1 1 0-7 3.5 3.5 0 0 1 0 7Zm0 3.5a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1a1 1 0 0 0-1-1Z"/></svg> <svg aria-hidden="true" class="dark astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M21.64 13a1 1 0 0 0-1.05-.14 8.049 8.049 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36a10.14 10.14 0 1 0 14 11.69 1 1 0 0 0-.36-1.05Zm-9.5 6.69A8.14 8.14 0 0 1 7.08 5.22v.27a10.15 10.15 0 0 0 10.14 10.14 9.784 9.784 0 0 0 2.1-.22 8.11 8.11 0 0 1-7.18 4.32v-.04Z"/></svg> <svg aria-hidden="true" class="auto astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M21 14h-1V7a3 3 0 0 0-3-3H7a3 3 0 0 0-3 3v7H3a1 1 0 0 0-1 1v2a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-2a1 1 0 0 0-1-1ZM6 7a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v7H6V7Zm14 10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-1h16v1Z"/></svg> </template><link rel="stylesheet" href="/it_docs/_astro/index.BsC2KTtW.css" /><script type="module" src="/it_docs/_astro/hoisted.CyidM0jj.js"></script>
<script type="module" src="/it_docs/_astro/page.CZ0TFQCk.js"></script></head> <body class="astro-bguv2lll"> <a href="#_top" class="astro-7q3lir66">Skip to content</a>  <div class="page sl-flex astro-vrdttmbt"> <header class="header astro-vrdttmbt"><div class="header sl-flex astro-kmkmnagf"> <div class="title-wrapper sl-flex astro-kmkmnagf"> <a href="/it_docs/" class="site-title sl-flex astro-m46x6ez3">  <span class="astro-m46x6ez3"> IT Docs </span> </a>  </div> <div class="sl-flex astro-kmkmnagf"> <site-search data-translations="{&#34;placeholder&#34;:&#34;Search&#34;}" class="astro-v37mnknz"> <button data-open-modal disabled class="astro-v37mnknz">  <svg aria-label="Search" class="astro-v37mnknz astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M21.71 20.29 18 16.61A9 9 0 1 0 16.61 18l3.68 3.68a.999.999 0 0 0 1.42 0 1 1 0 0 0 0-1.39ZM11 18a7 7 0 1 1 0-14 7 7 0 0 1 0 14Z"/></svg>  <span class="sl-hidden md:sl-block astro-v37mnknz" aria-hidden="true">Search</span> <svg aria-label="(Press / to Search)" class="sl-hidden md:sl-block astro-v37mnknz astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M17 2H7a5 5 0 0 0-5 5v10a5 5 0 0 0 5 5h10a5 5 0 0 0 5-5V7a5 5 0 0 0-5-5Zm3 15a3 3 0 0 1-3 3H7a3 3 0 0 1-3-3V7a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v10Z"/><path d="M15.293 6.707a1 1 0 1 1 1.414 1.414l-8.485 8.486a1 1 0 0 1-1.414-1.415l8.485-8.485Z"/></svg>  </button> <dialog style="padding:0" aria-label="Search" class="astro-v37mnknz"> <div class="dialog-frame sl-flex astro-v37mnknz">  <button data-close-modal class="sl-flex md:sl-hidden astro-v37mnknz"> Cancel </button> <div class="search-container astro-v37mnknz"> <div id="starlight__search" class="astro-v37mnknz"></div> </div> </div> </dialog> </site-search>    </div> <div class="sl-hidden md:sl-flex right-group astro-kmkmnagf"> <div class="sl-flex social-icons astro-kmkmnagf"> <a href="https://github.com/GGsmou" rel="me" class="sl-flex astro-wy4te6ga"><span class="sr-only astro-wy4te6ga">GitHub</span><svg aria-hidden="true" class="astro-wy4te6ga astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M12 .3a12 12 0 0 0-3.8 23.38c.6.12.83-.26.83-.57L9 21.07c-3.34.72-4.04-1.61-4.04-1.61-.55-1.39-1.34-1.76-1.34-1.76-1.08-.74.09-.73.09-.73 1.2.09 1.83 1.24 1.83 1.24 1.08 1.83 2.81 1.3 3.5 1 .1-.78.42-1.31.76-1.61-2.67-.3-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.14-.3-.54-1.52.1-3.18 0 0 1-.32 3.3 1.23a11.5 11.5 0 0 1 6 0c2.28-1.55 3.29-1.23 3.29-1.23.64 1.66.24 2.88.12 3.18a4.65 4.65 0 0 1 1.23 3.22c0 4.61-2.8 5.63-5.48 5.92.42.36.81 1.1.81 2.22l-.01 3.29c0 .31.2.69.82.57A12 12 0 0 0 12 .3Z"/></svg> </a> </div> <starlight-theme-select>  <label style="--sl-select-width: 6.25em" class="astro-4yphtoen"> <span class="sr-only astro-4yphtoen">Select theme</span> <svg aria-hidden="true" class="icon label-icon astro-4yphtoen astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M21 14h-1V7a3 3 0 0 0-3-3H7a3 3 0 0 0-3 3v7H3a1 1 0 0 0-1 1v2a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-2a1 1 0 0 0-1-1ZM6 7a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v7H6V7Zm14 10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-1h16v1Z"/></svg>  <select value="auto" class="astro-4yphtoen"> <option value="dark" class="astro-4yphtoen">Dark</option><option value="light" class="astro-4yphtoen">Light</option><option value="auto" selected="true" class="astro-4yphtoen">Auto</option> </select> <svg aria-hidden="true" class="icon caret astro-4yphtoen astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M17 9.17a1 1 0 0 0-1.41 0L12 12.71 8.46 9.17a1 1 0 1 0-1.41 1.42l4.24 4.24a1.002 1.002 0 0 0 1.42 0L17 10.59a1.002 1.002 0 0 0 0-1.42Z"/></svg>  </label>  </starlight-theme-select>  <script>
	StarlightThemeProvider.updatePickers();
</script>   </div> </div> </header> <nav class="sidebar astro-vrdttmbt" aria-label="Main"> <starlight-menu-button class="astro-jif73yzw"> <button aria-expanded="false" aria-label="Menu" aria-controls="starlight__sidebar" class="sl-flex md:sl-hidden astro-jif73yzw"> <svg aria-hidden="true" class="astro-jif73yzw astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M3 8h18a1 1 0 1 0 0-2H3a1 1 0 0 0 0 2Zm18 8H3a1 1 0 0 0 0 2h18a1 1 0 0 0 0-2Zm0-5H3a1 1 0 0 0 0 2h18a1 1 0 0 0 0-2Z"/></svg>  </button> </starlight-menu-button>    <div id="starlight__sidebar" class="sidebar-pane astro-vrdttmbt"> <div class="sidebar-content sl-flex astro-vrdttmbt"> <ul class="top-level astro-3ii7xxms"> <li class="astro-3ii7xxms"> <details open class="astro-3ii7xxms"> <summary class="astro-3ii7xxms"> <div class="group-label astro-3ii7xxms"> <span class="large astro-3ii7xxms">Overview</span>  </div> <svg aria-hidden="true" class="caret astro-3ii7xxms astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1.25rem;"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"/></svg>  </summary> <ul class="astro-3ii7xxms"> <li class="astro-3ii7xxms"> <a href="/it_docs/all/algorithms__data_structures/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Algorithms and Data Structures</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/architecture/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Architecture</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/backend/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">BackEnd</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/cli/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">CLI</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/code_complete_2-steve_mcconnel/" aria-current="page" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Notes of &quot;Code Complete 2nd edition&quot; by Steve McConnel</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/code_snippets/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Code_Snippets</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/css/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">CSS</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/design/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Design</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/fintech/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Fintech</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/frontend/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">FrontEnd</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/general/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">General</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/it/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">IT</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/js/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">JS</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/optimization/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Optimization</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/react/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">React</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/security/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Security</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/testing/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">Testing</span>  </a> </li><li class="astro-3ii7xxms"> <a href="/it_docs/all/ts/" class="astro-3ii7xxms"> <span class="astro-3ii7xxms">TS</span>  </a> </li> </ul>  </details> </li> </ul>  <div class="md:sl-hidden"> <div class="mobile-preferences sl-flex astro-wu23bvmt"> <div class="sl-flex social-icons astro-wu23bvmt"> <a href="https://github.com/GGsmou" rel="me" class="sl-flex astro-wy4te6ga"><span class="sr-only astro-wy4te6ga">GitHub</span><svg aria-hidden="true" class="astro-wy4te6ga astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M12 .3a12 12 0 0 0-3.8 23.38c.6.12.83-.26.83-.57L9 21.07c-3.34.72-4.04-1.61-4.04-1.61-.55-1.39-1.34-1.76-1.34-1.76-1.08-.74.09-.73.09-.73 1.2.09 1.83 1.24 1.83 1.24 1.08 1.83 2.81 1.3 3.5 1 .1-.78.42-1.31.76-1.61-2.67-.3-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.14-.3-.54-1.52.1-3.18 0 0 1-.32 3.3 1.23a11.5 11.5 0 0 1 6 0c2.28-1.55 3.29-1.23 3.29-1.23.64 1.66.24 2.88.12 3.18a4.65 4.65 0 0 1 1.23 3.22c0 4.61-2.8 5.63-5.48 5.92.42.36.81 1.1.81 2.22l-.01 3.29c0 .31.2.69.82.57A12 12 0 0 0 12 .3Z"/></svg> </a> </div> <starlight-theme-select>  <label style="--sl-select-width: 6.25em" class="astro-4yphtoen"> <span class="sr-only astro-4yphtoen">Select theme</span> <svg aria-hidden="true" class="icon label-icon astro-4yphtoen astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M21 14h-1V7a3 3 0 0 0-3-3H7a3 3 0 0 0-3 3v7H3a1 1 0 0 0-1 1v2a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-2a1 1 0 0 0-1-1ZM6 7a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v7H6V7Zm14 10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-1h16v1Z"/></svg>  <select value="auto" class="astro-4yphtoen"> <option value="dark" class="astro-4yphtoen">Dark</option><option value="light" class="astro-4yphtoen">Light</option><option value="auto" selected="true" class="astro-4yphtoen">Auto</option> </select> <svg aria-hidden="true" class="icon caret astro-4yphtoen astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M17 9.17a1 1 0 0 0-1.41 0L12 12.71 8.46 9.17a1 1 0 1 0-1.41 1.42l4.24 4.24a1.002 1.002 0 0 0 1.42 0L17 10.59a1.002 1.002 0 0 0 0-1.42Z"/></svg>  </label>  </starlight-theme-select>  <script>
	StarlightThemeProvider.updatePickers();
</script>   </div>  </div> </div> </div> </nav> <div class="main-frame astro-vrdttmbt">  <div class="lg:sl-flex astro-67yu43on"> <aside class="right-sidebar-container astro-67yu43on"> <div class="right-sidebar astro-67yu43on"> <div class="lg:sl-hidden astro-pb3aqygn"><mobile-starlight-toc data-min-h="2" data-max-h="6" class="astro-doynk5tl"><nav aria-labelledby="starlight__on-this-page--mobile" class="astro-doynk5tl"><details id="starlight__mobile-toc" class="astro-doynk5tl"><summary id="starlight__on-this-page--mobile" class="sl-flex astro-doynk5tl"><div class="toggle sl-flex astro-doynk5tl">On this page<svg aria-hidden="true" class="caret astro-doynk5tl astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1rem;"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"/></svg> </div><span class="display-current astro-doynk5tl"></span></summary><div class="dropdown astro-doynk5tl"><ul class="isMobile astro-g2bywc46" style="--depth: 0;"> <li class="astro-g2bywc46" style="--depth: 0;"> <a href="#_top" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Overview</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 0;"> <a href="#preface" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Preface</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 0;"> <a href="#foundation" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Foundation</span> </a> <ul class="isMobile astro-g2bywc46" style="--depth: 1;"> <li class="astro-g2bywc46" style="--depth: 1;"> <a href="#software-construction" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Software Construction</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#metaphors" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Metaphors</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#prerequisites" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Prerequisites</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#key-construction-decisions" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Key Construction Decisions</span> </a>  </li> </ul>  </li><li class="astro-g2bywc46" style="--depth: 0;"> <a href="#creating-high-quality-code" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Creating High-Quality Code</span> </a> <ul class="isMobile astro-g2bywc46" style="--depth: 1;"> <li class="astro-g2bywc46" style="--depth: 1;"> <a href="#design" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Design</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#classes" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Classes</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#routings" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Routings</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#defensive-programing" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Defensive programing</span> </a>  </li> </ul>  </li> </ul> </div></details></nav></mobile-starlight-toc></div><div class="right-sidebar-panel sl-hidden lg:sl-block astro-pb3aqygn"><div class="sl-container astro-pb3aqygn"><starlight-toc data-min-h="2" data-max-h="6"><nav aria-labelledby="starlight__on-this-page"><h2 id="starlight__on-this-page">On this page</h2><ul class="astro-g2bywc46" style="--depth: 0;"> <li class="astro-g2bywc46" style="--depth: 0;"> <a href="#_top" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Overview</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 0;"> <a href="#preface" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Preface</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 0;"> <a href="#foundation" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Foundation</span> </a> <ul class="astro-g2bywc46" style="--depth: 1;"> <li class="astro-g2bywc46" style="--depth: 1;"> <a href="#software-construction" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Software Construction</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#metaphors" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Metaphors</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#prerequisites" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Prerequisites</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#key-construction-decisions" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Key Construction Decisions</span> </a>  </li> </ul>  </li><li class="astro-g2bywc46" style="--depth: 0;"> <a href="#creating-high-quality-code" class="astro-g2bywc46" style="--depth: 0;"> <span class="astro-g2bywc46" style="--depth: 0;">Creating High-Quality Code</span> </a> <ul class="astro-g2bywc46" style="--depth: 1;"> <li class="astro-g2bywc46" style="--depth: 1;"> <a href="#design" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Design</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#classes" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Classes</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#routings" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Routings</span> </a>  </li><li class="astro-g2bywc46" style="--depth: 1;"> <a href="#defensive-programing" class="astro-g2bywc46" style="--depth: 1;"> <span class="astro-g2bywc46" style="--depth: 1;">Defensive programing</span> </a>  </li> </ul>  </li> </ul> </nav></starlight-toc></div></div> </div> </aside> <div class="main-pane astro-67yu43on">  <main data-pagefind-body lang="en" dir="ltr" class="astro-bguv2lll">    <div class="content-panel astro-7nkwcw3z"> <div class="sl-container astro-7nkwcw3z"> <h1 id="_top" class="astro-j6tvhyss">Notes of &quot;Code Complete 2nd edition&quot; by Steve McConnel</h1>  </div> </div>  <div class="content-panel astro-7nkwcw3z"> <div class="sl-container astro-7nkwcw3z"> <div class="sl-markdown-content"> <p><em>notes of Code Complete book (2nd edition) by Steve McConnel</em>
<em>this could by a part of Architecture note, but it is already kinda big :)</em></p>
<h2 id="preface">Preface</h2>
<p>This is a book about nearly every aspect of software development, with many and many examples of code, best practices etc, that came from different source(been white papers or just some new arising tech solutions)</p>
<ul>
<li>in its core, all of SE is built upon this practices, no matter the language or environment you are working in</li>
</ul>
<p>SE includes many parts(testing, building architecture, planning), but the main one is code construction, that is main part of all software development, that can’t be avoided or shourtcutted</p>
<h2 id="foundation">Foundation</h2>
<h4 id="software-construction">Software Construction</h4>
<p>Software construction - process of building/developing software(this includes testing, planning, designing etc, but for the most part it is about creation)</p>
<ul>
<li>basically creating a software is complex process, that includes many parts, that may or may not be included in particular process, depending on it’s scale, formality etc</li>
<li>note that detailed design, coding, debugging, integration and testing(manual and automatic) is also a part of development/construction</li>
<li>why it is important:
<ul>
<li>it is a central part of development cycle</li>
<li>code is main source of truth, so it needs to be good</li>
<li>construction always needs to be done</li>
</ul>
</li>
</ul>
<h4 id="metaphors">Metaphors</h4>
<p>Creating and learning metaphors in field you are working at is important part in communication, building understanding and creating something new, because it helps to grasp some hard parts by looking at similarities with smth simple</p>
<ul>
<li>metaphors can be bad, or just irrelevant, so they are evolving in their own way</li>
<li>metaphor in software engineering is not about algorithmic approach to something, it is more about general idea, that can lead to some solution(or at list be a guide on how to find it)
<ul>
<li>it is like algorithm vs pattern</li>
<li>this comes from fluent and diverse nature of SE</li>
</ul>
</li>
<li>metaphors can be combined</li>
</ul>
<p>common metaphors:</p>
<ul>
<li>developing software == writing code
<ul>
<li>brings to us that code must be readable, easily understandable, process of developing is built upon trial&#x26;error(in a way its true, but we always should account for planning first)</li>
<li>not accounts for planning, multiple developers in one project, maintenance, originality(it is better to use pre-existing solution, then imagine new one)</li>
</ul>
</li>
<li>developing software == doing farming
<ul>
<li>bring to us that we should do a bit at a time(incremental development)</li>
<li>not accounts that you still have control in-between process(after you plant seed and harvested the result)</li>
</ul>
</li>
<li>developing software == accretion
<ul>
<li>bring to us that we should scale system incrementally/iteratively/adaptively, we should form a base first and grow upon it, agile</li>
</ul>
</li>
<li>developing software == building
<ul>
<li><em>(compatible with accretion)</em></li>
<li>bring to us that we should:
<ul>
<li>pre-plan
<ul>
<li>how and what we plan can differ, depending on what we are doing(small scale projects can go without planning at all)</li>
</ul>
</li>
<li>define a problem, architecture, design, construct, optimize, review, test
<ul>
<li>otherwise, on scale, you will loose a lot of man-hours of re-doing
<ul>
<li>and if you don’t re-do, project will become a mess</li>
</ul>
</li>
</ul>
</li>
<li>use already created libraries, tools and languages
<ul>
<li>however, some parts can be written in-house to account for needs</li>
</ul>
</li>
<li>use different planning approaches(sometimes just general planning, sometimes in-details)
<ul>
<li>this also includes accounting for changes, as development goes</li>
</ul>
</li>
<li>be documented</li>
<li>be dived into parts, with assigning responsibilities for each one</li>
</ul>
</li>
</ul>
</li>
<li>applying patterns == using toolbox
<ul>
<li>bring to us that we should use proper tool for each problem</li>
</ul>
</li>
</ul>
<h4 id="prerequisites">Prerequisites</h4>
<p>Preparation is key in developing a software, but preparations can differ, depending on requirements</p>
<ul>
<li>if no planning is done, only think you can really do is damage control in process of construction</li>
</ul>
<p>why pre-plan:</p>
<ul>
<li>to make your software high-quality, it need to be in a good quality in all phase
<ul>
<li>quality at the end == testing</li>
<li>quality at the middle == construction</li>
<li>quality at the beginning == planning, designing etc
<ul>
<li>includes: problem definition, planning and designing the solution</li>
<li>with bad beginning you can only back-up and re-do</li>
</ul>
</li>
</ul>
</li>
<li>risk reduction</li>
</ul>
<p>what can go wrong in planning:</p>
<ul>
<li>person don’t know how-to do it OR just don’t want to
<ul>
<li>if you don’t want to, just consider arguments, or fail couple of times on scale :)</li>
</ul>
</li>
<li>not enough time to do so(strict deadlines, management etc)
<ul>
<li>it is important to find time for planning, with argumentation and arguing for it, here are some ways of how to argue:
<ul>
<li>don’t :)
<ul>
<li>quit or “just say it is what it is”</li>
</ul>
</li>
<li>pretend that you are</li>
<li>try to educate management on why you need to do so(all in all it is also part of your job)
<ul>
<li>appeal to logic - you can’t do smth big with no plan</li>
<li>appeal to analogy - house building, food chain(bad crop will poison you, eating a cow)</li>
<li>appeal to data - more changes later == more money to spend, because we need to rework each affected part(on scale)
<ul>
<li>it is about finding bugs as left as possible on scale of planning -> release
<ul>
<li>its like saying I want to live happily for 50 years of my life and party, than go to the gym(but you can live happily to 100 otherwise)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>as said, you need to know your software, to plan properly for it, so, here is guide</p>
<ul>
<li>I am too lazy to note all of this, so just know that with more scale and criticalness, you need to do more planning, testing, architecturing, inspections, formality etc</li>
</ul>
<p>hand-in-hand with pre-panning comes iterative approach</p>
<ul>
<li>basically we split whole project into chunks and after finishing each do improvements to whole system, taking in consideration new things</li>
<li>it is still important to have pre-planning, because it reduces cost and risks, but choosing to iterate over do whole thing sequential will add more reduction, as well as make every change come in portions(otherwise, after finishing the whole thing we need to invest some more time into improvements)
<ul>
<li>it is impossible to do 100% iterative or sequential, BUT it is useful to either pre-plan most of things and don’t deviate or pre-plan core stuff and mostly iterate
<ul>
<li>pre-planing is great for stable &#x26; predictable system, with fixed requirements, that has little risk and will be hard to change downstream, OTHERWISE choose iteration</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>problem definition is important part of planning, that defines what task are we solving</p>
<ul>
<li>problem definition is foundation of what we are going to do, it can’t define any solution or go too much in depth
<ul>
<li>it is ok to go deeper, if topic of project requires it</li>
</ul>
</li>
<li>usually it is done in user language</li>
<li>wrong definition will make you not solve problem at all</li>
</ul>
<p>requirements/specification - next step after problem definition, that defines what software required to do, without concrete solutions</p>
<ul>
<li>it is easy way to define user needs, not how programer sees it</li>
<li>requirements is a way to resolve arguments on program scope</li>
<li>stable requirements ensure that project won’t be changing in it’s core
<ul>
<li>it is a holy grail of SE, but it is not realistic, because with project development your and customer’s understanding of it will change, SO you need to adapt to this changes:
<ul>
<li>always stop and adjust if you requirement feel wrong</li>
<li>explain cost of requirements change and turn them into “nice to have” or “will be done later” or “out of scope for now”
<ul>
<li>still taking feedback is important, so create some procedures to take and implement it</li>
</ul>
</li>
<li>develop in cycles OR iterative approach</li>
<li>kill project if it is out-of-hand</li>
<li>evaluate is change of requirements is profitable to do</li>
</ul>
</li>
</ul>
</li>
<li>requirements to specify:
<ul>
<li>system inputs/outputs(data, how to work with it, validations etc)</li>
<li>external dependencies and ways to interact with them</li>
<li>use-cases by users</li>
<li>security</li>
<li>performance</li>
<li>reliability(consequences of failure, vital data, error handling, recovery)</li>
<li>flexibility</li>
<li>what need to be achieved and if we achieve is it enough to release</li>
<li>can users understand and agree with requirements</li>
<li>are we achieved tradeoffs between requirements</li>
<li>do we have enough, but not too much details</li>
<li>are requirements relevant, testable and what risk of each one changing</li>
<li>what are unknowns</li>
<li>is it reasonably possible to implement</li>
</ul>
</li>
</ul>
<p>next step is planning the architecture - frame that holds overall details about whole system and done as some document</p>
<ul>
<li>it acts as a structural guide to the system, that helps to independently maintain project by multiple dev. teams, while preserving quality</li>
<li>it must make development easy and understandable</li>
<li>architectural changes are pretty costly, but if you must do one, do it asap</li>
<li>when creating architecture it is important to consider many approaches and state why one has been chose over other
<ul>
<li>such move will act as future guidance on things done as they are</li>
</ul>
</li>
<li>architecture is based of components:
<ul>
<li>program organization - broad system overview, that defines all parts of a system, assigns concrete roles to each of them and connects(direct/indirect relationship OR no connection at all) them together
<ul>
<li>parts can differ in size from class to smth like Front-End in general</li>
<li>principles of localization and least information(part A knows as little as possible about part B) are important here</li>
</ul>
</li>
<li>major class organization - similar to program organization, but in scope of classes, with such details as state changes, hierarchies, class organization etc etc
<ul>
<li>specify only most important classes</li>
</ul>
</li>
<li>data design - describe how data is stored, accessed, all chosen data structures and table designs, present in system
<ul>
<li>important principle is data encapsulation, where it can be accessed only be responsible system OR via some APIs, that this system provide</li>
</ul>
</li>
<li>business rules - state all rules/requirements and how they effect the system</li>
<li>user interface - more detailed description(that already present in requirements) of UI part of a system
<ul>
<li>modularization principle is a key, so we could change one interface to other, without changes to business logic or data</li>
</ul>
</li>
<li>security - explain details on how we deal with authN&#x26;authR, how data/error exposed to user, how we work with user input, encryption etc</li>
<li>performance - if there are specific requirements for performance, architecture should state in what ways we are going to achieve them</li>
<li>scalability - explicitly state that scalability is not a concern OR define how system is going to scale in different directions(users, DBs, services etc)</li>
<li>interoperability - describe how resources are shared</li>
<li>i18n + l10i - if talking about low level staff it is about how we encode strings and why, for UIs it is a lot bigger problem :|</li>
<li>I/O - how to deal with it</li>
<li>error handling - program consists not only from happy path, so it is important to state how we are working with errors, by answering this questions:
<ul>
<li>what errors are recoverable and what not</li>
<li>how notify user about errors</li>
<li>how to log errors</li>
<li>will we prevent errors(validation of input for example) OR deal with the(wrong input is accepted with failure in process)</li>
<li>will error break the flow of program</li>
<li>conventions on error messages&#x26;details</li>
<li>how to handle errors</li>
<li>who is responsible for validation and error handling</li>
<li>how we work with errors(via built in instruments, lib or smth custom)</li>
<li>how failure tolerance(basically in depth recoverability of system) will be done
<ul>
<li>back-ups, algorithm/service swap if one that used is down or degrades, auto-restarts</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>feasibility - investigate(usually done with POCs) if system could be build in first place</li>
<li>prevent overengineering with stating the requirements</li>
<li>build/buy - investigate and state what can we use from open-source or buy and what need to be done in-house(with explanation how)
<ul>
<li>other case that similar to this topic is reusability of parts from previously built architecture</li>
</ul>
</li>
<li>change strategy - provide a ways for a project to be flexible and adapt on fly
<ul>
<li>it is more about of finding volatile parts, that can change in your system(ex. data format, service integration) and provide a way to localize interactions with them, so change won’t effect whole system</li>
</ul>
</li>
<li>architecture must be understandable, easy to read and natural in a way it solves problems
<ul>
<li>never state “we’ve always done it in this way”</li>
<li>architecture should be done in right size</li>
<li>it should provide multiple points of views</li>
<li>it must make sense</li>
</ul>
</li>
</ul>
<p>all in all prerequisites should take as much time as needed, with possibility of future improvements(that also take time and can be resolved by you OR with DRI of project)</p>
<ul>
<li>tho, you need to start somewhere, so don’t plan too much</li>
<li>the time you spend planning will always correlate with size and formality of project</li>
<li>be careful with not making/keeping prerequisites volatile, it is better to take time and develop them properly</li>
<li>architecture can be a separate sub-project of a project</li>
</ul>
<h4 id="key-construction-decisions">Key Construction Decisions</h4>
<p>Chapter about how-to choose right instruments for your job, to successfully build software, that was planned in prev. chapter</p>
<p>choosing programing language - important faze, because it will influence how you think about your problems, what steps you need to do, how your approach solutions</p>
<ul>
<li>it is very important from optimization perspective etc, BUT choosing wrong tool will lead to more problems in development, because you will constantly fight chosen language</li>
<li>development team must be familiar with language of choice to be productive
<ul>
<li>also big problem is writing in one language with mindset of another, this way you will have 0 benefits of chosen language and all problems of one from mind set
<ul>
<li><em>and also you will fight and hate chosen lang :)</em></li>
</ul>
</li>
</ul>
</li>
<li>high-level language brings speed, reliability, expressiveness and ease of hiring</li>
<li>certain languages is better in expressing and working with some problems more than other languages</li>
</ul>
<p>great large systems must have not only great architecture, but be consistent in details(naming, formatting, comments, file structures), otherwise you will end-up with semi structured mess, that requires more brain capacity to understand and maintain</p>
<ul>
<li>this concept is called low-level integrity</li>
<li>it is important to state such details beforehand, because it is almost impossible to make ongoing system consistent without them in a first place</li>
</ul>
<p>always program “into” language, this means decide what you need first AND only than try to implement with existing tools</p>
<ul>
<li>by doing things this way you can create much more complex things, that aren’t restricted by the env you work with</li>
<li>if you env is too primitive for your needs, you can switch or expand it
<ul>
<li>to expand: create conventions, standards, libs etc</li>
</ul>
</li>
</ul>
<p>all-in-all, good practice is to incorporate other good practices into your programs :)
here some of them, that wasn’t mentioned:</p>
<ul>
<li>define what procedures code should go through to be “merged into main”</li>
<li>is there place for pair programing in development flow?</li>
<li>decide what should be tested, in what form(unit, integration e2e etc), in what period(upfront, after been done), is there a place for manual testing and how to do it</li>
<li>define a set of tools(lang, programs, frameworks etc), that are needed to develop</li>
</ul>
<h2 id="creating-high-quality-code">Creating High-Quality Code</h2>
<h4 id="design">Design</h4>
<p>Design is important part to think through before start coding, BUT it often skipped in architecture, because it contains plenty of low level details</p>
<ul>
<li>it is possible to write detailed design, so coding will be done only mechanically, but mostly you will do some design with coding process</li>
</ul>
<p>problem with design is that requirements can shift, making design irrelevant OR after creating solving the problem, some unexpected part is revealed and design must be rethought</p>
<ul>
<li>it is generally hard to find right solution, with enough details and so on and so on</li>
<li>finding right tradeoffs, priorities, restrictions - key to good design</li>
<li>basically it is open-ended question and non-deterministic problem</li>
<li>it emerges through design reviews, discussions, writing and reviewing code</li>
</ul>
<p>to write good design, you need to understand some concepts</p>
<ul>
<li>complexity - project become more complex as it grows, this complexity will come from two sources: technical problems like managing tech stack etc, complexity of problem itself that need to be solved
<ul>
<li>when project fails due to technical reasons, it is often the problem of complexity(no one can fully understand what’s going on and how each change effects the system), SO it is important to manage complexity</li>
<li>to manage complexity, you should break program into independent parts, that you can work with one by one, keeping scope tight and small
<ul>
<li><em>our brain is small, so don’t force it to work with large context ;)</em></li>
<li>so
<ul>
<li>use single responsibility</li>
<li>divide system to sub-systems</li>
<li>work with domain problems and avoid low-level implementation details</li>
<li>keep things abstract</li>
</ul>
</li>
</ul>
</li>
<li>complexity rise for:
<ul>
<li>complex solution - simple problem</li>
<li>simple solution - hard problem</li>
<li>wrong solution - any problem</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>good design can be characterized as:</p>
<ul>
<li>minimal complexity</li>
<li>ease of maintenance - when designing, imaging that someone will maintain your code</li>
<li>loose coupling</li>
<li>extensibility - change in one place won’t effect other places</li>
<li>reusability</li>
<li>high fan-in - low level classes are highly re-usable through-out all codebase</li>
<li>low-to-medium fan-out - keep dependency list of a class small</li>
<li>portability - ease of migration to other stack</li>
<li>leanness - don’t keep unneeded code in codebase
<ul>
<li>it is great general advise when doing something, “don’t finish when there is nothing more to add, finish when there is nothing more to remove”</li>
</ul>
</li>
<li>stratification - each level of system must be independent from another one
<ul>
<li>interfaces are great to tackle this problem</li>
</ul>
</li>
<li>standard techniques - stick to default approaches, if possible</li>
</ul>
<p>levels of design</p>
<ul>
<li>whole system</li>
<li>sub-systems and packages - how system is divided into parts and how those parts communicate
<ul>
<li>key point is to keep connections as loosely coupled as possible, to preserve order and structure
<ul>
<li>(loose->tight coupling) A interacts with B interface -> A shares classes and logic with B -> A classes inherit from B classes and vise versa</li>
<li>keep an eye on cyclic dependencies, they are harmful to have</li>
</ul>
</li>
<li>common sub-systems:
<ul>
<li>business rules - some set of rules, related to your program</li>
<li>UI - set of one or more independent(from other parts and from each other) systems, that used to display data</li>
<li>DB access - layer that hides details of querying the DB, usually some API level</li>
<li>System dependencies - direct calls to system that your are working with(like OS) should be moved to separate sub-system, so it is easy to change envs
<ul>
<li>often it is already done by libs, BUT this doesn’t mean that you should spread your lib all over the place, maybe use some patter(like Strategy) to access abstract system via interface and some lib implementation can be passed in</li>
</ul>
</li>
</ul>
</li>
<li>can be skipped for small systems</li>
</ul>
</li>
<li>classes - decompose all sub-system into classes, with defined interfaces and connections</li>
<li>routines - specify all private methods of class and how are they called
<ul>
<li>often done mentally, while coding</li>
<li>can influence level 3</li>
</ul>
</li>
<li>inside the routines - describe logic of each routing
<ul>
<li>often done mentally, while coding</li>
<li>can include writing pseudocode, but not really necessary</li>
</ul>
</li>
</ul>
<p>heuristics - ways to think about design, that act as guidance to it</p>
<ul>
<li>design is non-deterministic, so instead of concrete steps we can use heuristics to do it</li>
<li>we are using heuristics as main way to hide complexity by: hiding details to reduce cognitive load, protecting variations
<ul>
<li>variations can include: algorithms, types, structures, boolean flags</li>
</ul>
</li>
<li>---</li>
<li>identify real world objects - define set of real and synthetic objects, and iteratively add more details to each object OR build better general composition
<ul>
<li>identify set of objects with data+methods
<ul>
<li>identify only properties, relevant to the system, not for general object(ex. human can have different eyes color, but we don’t care about it in LibraryApp)</li>
<li>we can add synthetic properties, relevant to system, but not for real world</li>
</ul>
</li>
<li>answer what can be done to each one</li>
<li>answer what each object can do to others
<ul>
<li>inheritance and object nesting included here too</li>
</ul>
</li>
<li>define public/private parts of each object</li>
<li>define object’s public interface
<ul>
<li>don’t forget about protected one too</li>
</ul>
</li>
</ul>
</li>
<li>form consistent abstractions - use abstractions for higher levels of planning, to avoid unnecessary details, when talking about some concepts
<ul>
<li>example: base classes with only public interface</li>
<li>important to keep system easy to understand and operate with</li>
<li>it is used on any design level</li>
</ul>
</li>
<li>encapsulate implementation details - more restrictive abstraction variation, that forbids to look at any details, you only allowed to work with general picture</li>
<li>inherit if it makes things simpler - inheritance and polymorphism are keys to simpler systems, BUT don’t overuse it, it increases systems coupling</li>
<li>hide info(encapsulation) - basically an OOP’s encapsulation, where you hide private properties of class inside of it
<ul>
<li>in it’s core it prevents usage of method, you marked as private, there for you can easily change it and do as little refactor as possible
<ul>
<li>when talking about public API, you won’t be able to change it at all, so don’t overexpose things</li>
</ul>
</li>
<li>this is performing complexity hiding</li>
<li>it might be useful to hide types this way, for example use some generic IdClass, that will expose possible operations with ID, but don’t give out value and it’s actual type to outside world</li>
<li>ways to hide info:
<ul>
<li>hard coded value -> constant</li>
<li>extract UI and any interactions with it separately from BE and vise versa</li>
<li>direct use of global data -> some getter/methods of accessing the data</li>
<li>avoid circular dependencies</li>
<li>avoid premature optimizations, that aren’t needed, but reduce encapsulation</li>
</ul>
</li>
<li>always and always ask yourself: “Does this part need to be exposed?” or “What should I hide?” in all levels of design</li>
</ul>
</li>
<li>identify areas that will likely change - it is about protected variation from GRASP, basically we striving to identify areas that can change and try to keep effect from change as low as possible
<ul>
<li>to achieve:
<ul>
<li>identify what can be changed(from requirements or by analyzing)</li>
<li>encapsulate this part via some Class or other structure</li>
<li>keep public interface of this structure stable, so it hides all volatile details</li>
</ul>
</li>
<li>what can be changed:
<ul>
<li>business rules</li>
<li>hardware(OS), software(libs) or similar to them dependencies</li>
<li>input/output data format</li>
<li>unstable or bad designed parts
<ul>
<li>especially when migration from old approach, it is great to interact with it from one place inside system, so if smth goes wrong, you need to modify only this one part</li>
</ul>
</li>
<li>boolean status -> enum status
<ul>
<li>also, when working with several states, it is great to hide logic of working with them inside respective class(this way <code dir="auto">if (!error &#x26;&#x26; statusCode == 200)</code> won’t spread everywhere)</li>
</ul>
</li>
<li>hardcoded values -> constants</li>
</ul>
</li>
<li>if change is less likely, it can be more poorly isolated, BUT if it is not likely, but easy to account, it is always better to isolate
<ul>
<li>ex: it is not reasonable to encapsulate React from your app, BUT maybe testing lib will be changed in future, so create a wrapper</li>
<li>good unchangeable candidate is system’s core</li>
</ul>
</li>
</ul>
</li>
<li>loose coupling - keep distant systems parts as least related as possible
<ul>
<li>relationship must be loose, flexible, simple and detached from each other</li>
<li>criteria:
<ul>
<li>size - number of parameters, public methods, connections</li>
<li>visibility - all actions must be understandable and easy to spot
<ul>
<li>ex: mutation-query separation</li>
</ul>
</li>
<li>flexibility - ease of reusability and connectivity between parts
<ul>
<li>ex: take several properties of an object as parameters and not whole object to make it easy to reuse function elsewhere</li>
</ul>
</li>
</ul>
</li>
<li>kinds:
<ul>
<li>data-parameter - all parameters passed inside are primitives</li>
<li>object - one object is coupled to other object</li>
<li>transitive - one object uses other object to get access to third object</li>
<li>innerworkings - one object knows that other object has some logic to be performed before it can perform something else
<ul>
<li>passing specific flags</li>
<li>modifying global state</li>
<li>calling specific methods</li>
<li>module2 knows that it will get baseObject from module1, so it performs additional casting</li>
</ul>
<hr>
<ul>
<li>it is the worst way to couple things, because it will silently break after any change to logic</li>
<li>basically try to build abstract communication between modules and avoid any details knowledge</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>use common design pattern, like GoF
<ul>
<li>benefits:
<ul>
<li>common language with other devs
<ul>
<li>great benefit is you can shuffle through options much faster, when discussing solutions</li>
</ul>
</li>
<li>ready made and tested solution for discovered problems
<ul>
<li>it is more error prone</li>
<li>can be evolved into more specific solution, for non-standard problem</li>
</ul>
</li>
</ul>
</li>
<li>never force your code/thinking into patterns, such solution may not be valuable for your case
<ul>
<li>shifting towards pattern can improve understandability, but never shift just for that</li>
</ul>
</li>
<li>never use pattern just to use it</li>
</ul>
</li>
<li>other heuristics:
<ul>
<li>high cohesion - how strongly related functionality of your class/method/module etc</li>
<li>organize code in hierarchical manner - keep structure of an app from most abstracted thing(ex: page) to leas abstracted thing(ex: button and it’s properties)
<ul>
<li>great as layering technique and smth, that let’s you achieve information hiding and abstraction</li>
</ul>
</li>
<li>formalize class contract - clear stating what, how and in what constraints class can do AND what can be done with it, makes process of creating, maintaining and using class more resilient</li>
<li>assign responsibilities - always ask what this object must do</li>
<li>design code for tests - reduce dependencies and responsibilities of each part of code, so it is easy to test it</li>
<li>always consider what could go wrong</li>
<li>choose when do to what in code - doing smth to early or upfront makes code easier, but less cohesioned and less flexible</li>
<li>move logic to some predefined place - ex: don’t inline calculations, place it inside class’s method and call it like so, so it is easy to find and change it</li>
<li>consider brute force if elegant solution is hard to achieve</li>
<li>use diagrams</li>
<li>keep design modular
<ul>
<li>each module is black box, for abstraction reasons</li>
</ul>
</li>
</ul>
</li>
<li>---</li>
<li>how to use heuristics:
<ul>
<li>understand a problem
<ul>
<li>restate a problem for better understanding</li>
<li>consider working with part of the problem or with abstracted problem</li>
</ul>
</li>
<li>create a plan
<ul>
<li>base it on previous plans</li>
<li>base it on unknowns</li>
</ul>
</li>
<li>cary out with plan
<ul>
<li>always check if you on the right way</li>
</ul>
</li>
<li>looking back
<ul>
<li>always check if you solution is what actually needed for this problem</li>
</ul>
</li>
<li>all in all, try different approaches of thinking about the problem OR just take a break and come back later OR solve part of it and come back later with more info and knowledge</li>
</ul>
</li>
</ul>
<p>design practices - some steps to produce great design</p>
<ul>
<li>iterate - design couple of times, with new knowledge
<ul>
<li>try different approaches: focus on low and high levels separately</li>
</ul>
</li>
<li>divide and conquer - divide design into parts and work with them separately</li>
<li>work with Top-Down and Down-Top approaches
<ul>
<li>Top-Down - start from most abstracted parts and add details
<ul>
<li>it is easy for brain to work with generalities and small number of details</li>
<li>start from abstract, decompose until it is easier to code, iterate until system is understandable</li>
<li>benefits: it is easy to break big into small, no need to worry about details(that can change) on early steps</li>
</ul>
</li>
<li>Down-Top - start from smallest part of system and generalize
<ul>
<li>some systems are so abstract, that it is hard to start, so try to focus on what the system need to do(in most simple representations as possible) and iterate from there</li>
<li>hardware/system restrictions can be low-level details, that will shape overall picture, so also great way to start</li>
<li>benefits: final system will be more compact, easy to find what can be reused</li>
<li>problems: hard to use exclusively and can result in partial final design, you can start from the wrong place</li>
</ul>
</li>
</ul>
</li>
<li>experimental prototyping - if you are blocked by unknown parts, try to find them out with writing a minimum, throw away code, that will be used as base for completing the design
<ul>
<li>please, don’t do real development on this stage, just some testing</li>
<li>always state clearly what are unknowns that need to be solved by prototype</li>
<li>always write throw-away code
<ul>
<li>if it is hard, don’t use production language or choose garbage naming</li>
</ul>
</li>
</ul>
</li>
<li>collaborative design - always collaborate(formally and especially informally), when designing
<ul>
<li>white boarding, coffee talk, pair programing, formal meetings, ADR/PRD/RFC, try to forget what did you do and later do self-review, forums</li>
<li>creative approaches are the first what need to be done, but finalization is always must be formal</li>
</ul>
</li>
<li>how to capture the design:
<ul>
<li>in code: readme, comments, examples, docComments</li>
<li>internal wiki(just a great tool overall)</li>
<li>write, share and save summarize of large design decisions</li>
<li>make a photos of whiteboards</li>
<li>do charts, diagrams(UML) etc
<ul>
<li>UML and similar solutions is great, because it has standard notations in it</li>
</ul>
</li>
<li>CRC cards</li>
</ul>
</li>
</ul>
<blockquote>
<p>The more dogmatic you are about applying a design method, the fewer real-life problems you are going to solve</p>
</blockquote>
<h4 id="classes">Classes</h4>
<p>Class is great tool for building encapsulation(this can be encapsulation of data+functionality OR just some service functionality, like helpers, with no related data)</p>
<p>ADT(abstract data types) - collection of data and operations that operate on data</p>
<ul>
<li>it is key term for building OOP style classes with good encapsulation and high cohesion and not just loosely related collections of data + operations</li>
<li>it defines, that we should treat data and operations in sync, with abstraction element(example: we aren’t just adding entity to array, we adding customer to the orders queue)</li>
<li>benefits:
<ul>
<li>we can hide implementation details(ex. types)</li>
<li>encapsulation and localization of changes
<ul>
<li>testing will be easier this way</li>
<li>more error prone approach</li>
<li>data is localized and always accessible</li>
</ul>
</li>
<li>we can create more understandable interface for our class
<ul>
<li>self-documentation comes as a bonus</li>
</ul>
</li>
<li>no knowledge of low-level details is needed, when working with interface
<ul>
<li>as said before, we don’t treat list as list, we treat list as some real data collection, with specific operations bound to it</li>
<li>note that you can layer ADTs, for example create custom ADT for Queue and then wrap it inside some AppointmentQueue ADT
<ul>
<li>note that name AppointmentQueue includes “Queue”, because it defines functionality, not an algorithm, it is a bad practice of exposing more details than needed, when using names like AppointmentFileStorage, because you can’t reuse it as AppointmentCacheStorage, while it can have identical interface, but differ in implementation</li>
</ul>
</li>
<li>don’t neglect creating small classes, it is easier to extend and the benefit of self-documentation is here</li>
</ul>
</li>
<li>polymorphism</li>
</ul>
</li>
<li>how to work in non-OOP env(if you happen to be unlucky <code dir="auto">:)</code>)
<ul>
<li>create a manager wrapper, that can keep track of data, related to instance, via some id, passed as param
<ul>
<li>alternative is to create one method, that will set currentlyInUse ADT, that will be shared by all other methods, so we need only one method to accept id and no one else
<ul>
<li>note the problem of shared state</li>
</ul>
</li>
</ul>
</li>
<li>manage data by user of ADT and pass it directly to ADT methods
<ul>
<li>be careful not working with data in any other manner, because it breaks the encapsulation</li>
</ul>
</li>
<li>work with your ADT as with Singleton
<ul>
<li>note the problem of shared state</li>
</ul>
</li>
</ul>
</li>
<li>why not classes?
<ul>
<li>Class is ADT, but on steroids, like inheritance, polymorphism etc</li>
</ul>
</li>
</ul>
<p>how create class interface</p>
<ul>
<li>keep it abstract</li>
<li>keep high cohesion
<ul>
<li>if it not cohesient enough, it must be consistent instead OR fixed</li>
</ul>
</li>
<li>always make internal things private/protected
<ul>
<li>be careful with inheritance here, you can try do smth like UserList extends List, BUT it can be dangerous, because now we state that UserList “is a” List and will expose all low level operations
<ul>
<li>if it need no expose operations, overwrite them with more abstract once, it it not, better not to expose and do smth like UserList.#listInstance and delegate all work to this private instance
<ul>
<li>Facade is great here, because we can expose only needed parts, change inner logic easily without breaking changes etc</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>keep it single purpose(employ operations can’t be mixed with list operations)</li>
<li>check if you need an opposite operation(add - remove), BUT add only if it is needed</li>
<li>be careful with interfaces, that have operation that must be called in order
<ul>
<li>it is unmaintainable, will be misused, need comments as explanations</li>
<li>hide this details inside OR ensure clear errors(ex: invariant)</li>
</ul>
</li>
<li>always recheck this list, when extending class</li>
</ul>
<p>how properly encapsulate - strongly related to concept of abstraction and helps preventing to even have possibility to look into details</p>
<ul>
<li>always tend to make access stricter, even if you not sure
<ul>
<li>remember about “Law of Demeter”</li>
</ul>
</li>
<li>exposing getter+setter > exposing data field
<ul>
<li>note that it can make classes more bloated, so be careful with this concept, BUT it makes code type independent, makes it easier to expand the behavior etc</li>
</ul>
</li>
<li>avoid making assumptions about how class will be used</li>
<li>be careful with introducing two highly coupled classes
<ul>
<li>State patter is one of possible exceptions</li>
</ul>
</li>
<li>prioritize read+maintenance time over write time</li>
<li>don’t introduce violation of semantic encapsulation, some examples:
<ul>
<li>interface have optional props, BUT not passing this props results in error</li>
<li>you know that <code dir="auto">.initConnection</code> call can be avoided, because <code dir="auto">.queryUser</code> operation will do it for you</li>
<li>using not related constant <code dir="auto">ANIMATION_TIME</code> in context of debouncing query, because they have same value of <code dir="auto">250</code></li>
</ul>
</li>
<li>make class complete, so there is no need to build upon it’s functional</li>
<li>---</li>
<li>all in all, when you need to look at the implementation, to work with class, consider that your encapsulation is broken
<ul>
<li>it is generally better to ask code author to reimplement interface, then check implementation details of ask for explanation</li>
</ul>
</li>
</ul>
<p>some common implementation and design issues within classes</p>
<ul>
<li>if you have “has a” relationship, use Containment
<ul>
<li>be careful with using private data field of Contained object inside a class
<ul>
<li>if it is supported by your language</li>
<li>it creates a discussed before “friend” classes</li>
</ul>
</li>
<li>be careful with introducing too many Containments(no matter if it is plain data type or complex, like object)</li>
<li>generally, when you need control over your interface, use Containment, otherwise inheritance is valid option</li>
</ul>
</li>
<li>if you have “is a” relationship, use Inheritance(“is a” means some class is a more specialized version of it’s parent)
<ul>
<li>helps removing code duplication, but increases coupling, so be careful</li>
<li>always ask yourself:
<ul>
<li>will method have default implementation or will it be overwrited down the road
<ul>
<li>basically we have: abstract method, implemented overridable method, implemented non-overridable method</li>
</ul>
</li>
<li>will field be accessible to child or not</li>
</ul>
</li>
<li>remember about Liskov substitution principle
<ul>
<li>it avoids details leakage and problems with semantic encapsulation</li>
<li>use composition, if you see yourself breaking LSP</li>
</ul>
</li>
<li>mark non inheritable class as “final”(if you lang supports it)</li>
<li>if you don’t need to inherit all method, use delegation instead, OR change inheritance tree</li>
<li>don’t reuse names of non-overridable fields in child class
<ul>
<li>this breaks polymorphism</li>
</ul>
</li>
<li>tend moving common functionality as high in tree as possible</li>
<li>be careful with singletons, they often can be confused with simple objects</li>
<li>don’t design ahead, creating base class, that has only one child, it increases complexity
<ul>
<li>there might be need for future-proofing, but in general avoid it</li>
</ul>
</li>
<li>avoid deep inheritance
<ul>
<li>too much complexity will be introduced</li>
</ul>
</li>
<li>polymorphism > type checking
<ul>
<li>if talking about inheritance, type checking is still great for diffing different types</li>
</ul>
</li>
<li>private > protected, otherwise encapsulation is broken
<ul>
<li>great way to introduce such child-parent connection is via some protected method, that acts as indirect access layer to private field, IF such connection is needed</li>
</ul>
</li>
<li>avoid multiple inheritance, to avoid mega complexity ;)
<ul>
<li>it is appropriate for building independent, non expandable, mixins</li>
</ul>
</li>
</ul>
</li>
<li>how to implement class properties
<ul>
<li>minimize number of methods, BUT don’t overdo it
<ul>
<li>creating “super” classes is bad, BUT breaking and coupling them too much is even worst(and kinda pointless)</li>
</ul>
</li>
<li>make property or constructor private if needed
<ul>
<li>private constructor is great thing to do, when creating Factory or Singleton</li>
</ul>
</li>
<li>be careful with introducing coupling between classes, where one class is too much dependent on other one</li>
<li>be even more careful with indirect calls like so: <code dir="auto">this.aObj.bObj.callMethod()</code></li>
<li>initialize all properties of objects
<ul>
<li>reduces type problems with partial object AND highlights places, where object is misused</li>
</ul>
</li>
<li>try to always deep-copy(often performance tradeoff is negligible, but complexity reduction is drastic, ESPECIALLY for smth like React)
<ul>
<li>it is complex task for nested objects, BUT some libs or avoiding deep nesting is great strategy</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>reasons to create class:</p>
<ul>
<li>model real-world object - each real-world thing need one object with respective fields attached to it
<ul>
<li>great for achieving DDD</li>
</ul>
</li>
<li>model abstract object - it might be beneficial to abstract common things of real-world object into some abstract objects to enforce DRY or reusability
<ul>
<li>non-deterministic process and can result in different abstractions for same problem</li>
</ul>
</li>
<li>reduce complexity - hide any details inside an object, to make project easier to work with, understand, DRY, maintainable and correct</li>
<li>isolate complexity - create one thing in isolation and reuse it
<ul>
<li>if you need to modify, fix, change it - only one place is effected</li>
</ul>
</li>
<li>hide implementation details - hide types, external integrations, libs etc</li>
<li>isolate points of change</li>
<li>hide global data - create a StateManager object and expose data via methods, not directly</li>
<li>merge multiple variables into one object(if they are related)</li>
<li>create Controller class - work with points of control(DB connection, in-memory data etc) in one centralized place and way</li>
<li>create reusable code
<ul>
<li>can be viewed as utils OR as code, that can be even shared between programs
<ul>
<li>this way we can easily create “family” of programs, that have many similar parts
<ul>
<li>it is often called a “platform” part of all codebase</li>
</ul>
</li>
</ul>
</li>
<li>don’t create reusable code, it it doesn’t make much sense and adds complexity</li>
</ul>
</li>
<li>---</li>
<li>note: even if you don’t have Classes, always modularize your app, BUT if you have, Class can be a part of some bigger module too</li>
<li>be careful with:
<ul>
<li>god/super classes - too big classes, classes that interacts too deep with other classes, classes that know too much</li>
<li>redundant classes - don’t keep classes just because
<ul>
<li>also class with no behavior MIGHT be redundant</li>
</ul>
</li>
<li>avoid behavior only classes
<ul>
<li>detected if class is named as verb(<code dir="auto">StringBuilder</code>)</li>
<li>it is more often then not can be specialized and merged into dependent class</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>other about classes:</p>
<ul>
<li>always keep an eye on language specific staff(how it works, what common agreements/patterns exist)</li>
<li>it is beneficial to pack group of related classes intro packages
<ul>
<li>if it custom build system, always enforce standards for private/public, code&#x26;project organization</li>
</ul>
</li>
</ul>
<h4 id="routings">Routings</h4>
<p>Routing == method/function, invocable for single purpose, in this section will be presented how create high quality once</p>
<p>smells of routine:</p>
<ul>
<li>poor naming</li>
<li>no self-documentation</li>
<li>inconsistent code style and unreadable layout</li>
<li>param modification is present</li>
<li>direct global data access</li>
<li>multi-purpose</li>
<li>no validation</li>
<li>magic numbers</li>
<li>unused vars/params</li>
<li>working with ref param as value param and vise versa</li>
<li>too many params</li>
<li>poor params order</li>
<li>poor params naming</li>
</ul>
<p>base goals of routine:</p>
<ul>
<li>code readability</li>
<li>code reusability</li>
</ul>
<p>reasons to create routine:</p>
<ul>
<li>reduce complexity (as you might expect <code dir="auto">:)</code>)
<ul>
<li>less duplication</li>
<li>easier to change code</li>
<li>no need to remember implementation details</li>
</ul>
</li>
<li>introduce abstraction
<ul>
<li>break routings into smaller once</li>
<li>document code purpose</li>
</ul>
</li>
<li>DRY
<ul>
<li>fixes shotgun problem</li>
</ul>
</li>
<li>subclasses extension - easier to override smth small and understandable</li>
<li>hide operations order (reduce complexity)</li>
<li>hide pointers (reduce complexity)</li>
<li>improve portability - any non-default feature/dependency can be broken to reusable routines</li>
<li>simplify boolean - create self-documentation to boolean operations, that are always hard to read
<ul>
<li>or any operation to be fair</li>
<li>we also have an opportunity to better structure operation itself</li>
</ul>
</li>
<li>improve - any improvements are easier to make to one part of code and not all program</li>
</ul>
<p>ALWAYS tend for smaller routines, while it is beneficial sometimes to do otherwise, almost always breaking the code is good</p>
<ul>
<li>also don’t be ashamed of creating small or “stupid” routines</li>
<li>it might be, that small routine will grow eventually(validation etc), so small is good place to start</li>
</ul>
<p>how-to design routine:</p>
<ul>
<li>cohesion is important here, it determines how closely related operations inside routine are
<ul>
<li>routing, that performs multiple actions, will have low cohesion</li>
<li>among everything else, it makes your code error-prone</li>
<li>ways to achieving cohesion
<ul>
<li>do only one thing (main way)</li>
<li>perform operation sequentially close
<ul>
<li>ex: I need compute date of birth, age and salary, SO it must be done in this order, not with salary in between
<ul>
<li>to achieve you can structure your code in such way OR force <code dir="auto">calcAge</code> use <code dir="auto">getBirth</code> inside and don’t accept as param</li>
</ul>
</li>
</ul>
</li>
<li>don’t place operation closely, that relate only to data, that provided to them from above
<ul>
<li>it is better to initialize/receive data as close as possible to code, that it will be used by</li>
</ul>
</li>
<li>avoid direct execution of related functionality, rather delegate it
<ul>
<li>ex: <code dir="auto">Init</code> code may have may things inside of it, BUT if it delegates those things to other routings, rather then executing directly, it is ok
<ul>
<li>we have cohesion by purpose this way</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>what to avoid, so cohesion is high:
<ul>
<li>don’t combine calls in order, that have no need to be combined in first place
<ul>
<li>ex: I need to get array of 3 values about user, so I will call 3 gets in a row here
<ul>
<li>it rather be changed to getting all user data, OR some other way of destruction</li>
</ul>
</li>
</ul>
</li>
<li>don’t combine calls with boolean flags
<ul>
<li>ex: if this I will do <em>some large part of code</em>, else <em>other large part</em>
<ul>
<li>better to split it into two separate actions</li>
<li>if you need shared data, just access it from hire context, like class</li>
</ul>
</li>
<li>note: event handle OR command dispatcher is great pattern, that is exception here</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>how-to name a routine:</p>
<ul>
<li>use name that fully describes your routine
<ul>
<li>if you notice <code dir="auto">and</code>s in your names, this probably means, that this routine has too many responsibilities</li>
</ul>
</li>
<li>be careful with too elastic names like <code dir="auto">CalculateSmth, PerformSmth, DoSmth</code>, it is better avoid them
<ul>
<li>exceptions are cases, like <code dir="auto">HandleSmth</code>, when used in context of handling events</li>
<li>if it is hard to pick other name, it is a clear signal that routine has too broad purpose, related to it</li>
</ul>
</li>
<li>don’t use numbers to differ routines, it will lead to indistinguishable functions</li>
<li>strive for clearness in a name, don’t try to make it short
<ul>
<li>good point is that routine can be bound to class, so <code dir="auto">User.getReport()</code> has same meaning as <code dir="auto">User.getUserReport()</code> and you can use shorter variation
<ul>
<li><code dir="auto">getReport</code> - example of verb+object name type, that is great example of creating an understandable name</li>
<li><code dir="auto">User.getUserReport</code> - is not only redundant in size, but it will break inheritance, example:
<ul>
<li><code dir="auto">Check</code> overrides <code dir="auto">printDocument</code> to “print checks”, BUT naming <code dir="auto">Check.printDocument</code> is stays the same, so it is confusing</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>use opposite naming in same format
<ul>
<li>if we have <code dir="auto">OpenFile</code>, we can’t have <code dir="auto">fClose</code> or <code dir="auto">FileClose</code>, IT MUST BE <code dir="auto">CloseFile</code></li>
</ul>
</li>
<li>establish same conventions for common naming</li>
</ul>
<p>don’t introduce too big routines…by amount of logic/data, length doesn’t really matter</p>
<p>how-to work with params:</p>
<ul>
<li>establish consistent order of parameters, examples:
<ul>
<li>sort by role: input, input + output, output</li>
<li>sort by role C-style: output related, input</li>
<li>onError callback goes first</li>
</ul>
<hr>
<ul>
<li>keep similar order between similar functions</li>
</ul>
</li>
<li>if value can’t be changed mark it as <code dir="auto">readonly</code>, <code dir="auto">const</code> or some other way, that ideally is backed-up by your language
<ul>
<li>otherwise conventions are here to help</li>
</ul>
</li>
<li>remove unused params
<ul>
<li>linters are here for you, to enforce it</li>
</ul>
</li>
<li>don’t modify params directly
<ul>
<li>this will make impossible to use them later in routine AND will require contextual knowledge about routine, when working with it</li>
<li>this will make variable multi-purpose</li>
</ul>
</li>
<li>add comments, invariants or asserts to state that parameter has additional requirements to it
<ul>
<li>otherwise, handle this requirements inside routine(as validation step)</li>
</ul>
</li>
<li>keep an eye on number of params:
<ul>
<li>too many params result in harder to understand code</li>
<li>passing too many params between routines result in high coupling
<ul>
<li>if this routines are connected, put them into class and access data from-inside a class</li>
</ul>
</li>
</ul>
</li>
<li>how pass objects?
<ul>
<li>first way - only requires fields from it</li>
<li>second way - full object</li>
<li>ideal middle ground - “it depends” on how routine works with object, if it coupled to object or connected, better to pass full object and keep it flexible, IF it just needs some data and it is not intentional for it to originate from same object, accept only 3 params</li>
<li>indications of problem:
<ul>
<li>passing non-complete objects, OR create objects in place, for routine itself</li>
<li>frequently changing number of params, that could be accessed directly from object</li>
</ul>
</li>
</ul>
</li>
<li>always pass params of specified type, don’t hope for a chance that it will work OR for compiler to save you</li>
</ul>
<p>procedure VS function</p>
<ul>
<li>note: in modern languages it has only semantic meaning</li>
<li>procedure can’t return anything, but still can take and change pointer values, SO it is used to perform actions
<ul>
<li>can return status still, but it is debatable</li>
</ul>
</li>
<li>function can return only one value, determined by it’s name, and it is it’s sole purpose
<ul>
<li>notes:
<ul>
<li>always return stated value(linter or compiler is here to help)</li>
<li>never return pointer to local value, it will invalidate after function is completed</li>
</ul>
</li>
</ul>
</li>
<li>---</li>
<li>does it makes much scenes for some TS dev to remember it? Can’t say, it is a semantic things, so use it if necessary, BUT try not to overcomplicate things</li>
</ul>
<h4 id="defensive-programing">Defensive programing</h4>
<p>Create code, that can survive inappropriate usage, with proper behavior</p>
<ul>
<li>this means we always assume, that data will be invalid and need to work with it accordingly</li>
<li>we can avoid checks, if they already done by compiler, linter etc, BUT it is not always that easy and additional help from us is important</li>
</ul>
<p>Basically, “garbage in == garbage out” out is bad strategy, it is better to result in some strict way: error, no response, compilation failure etc</p>
<p>Basics of defense:</p>
<ul>
<li>check data: number ranges, string sizes, format of data, SQL/HTML injections etc
<ul>
<li>it always relevant for working with external data AND might be relevant on per function level</li>
</ul>
</li>
<li>decide what is suitable to do AND do it</li>
<li>note: defense isn’t first resort, when talking about routines, great design and abstraction is key, BUT it still can be useful there</li>
</ul>
<p>ways to defense:</p>
<ul>
<li>assertion - perform runtime check, do nothing, if everything is ok OR throw error, if smth is wrong
<ul>
<li>great for large problems to trace any issue OR avoid mess of recovering from state, that isn’t possible in first place</li>
<li>always document assertion meaning</li>
<li>it is possible to remove assertions from compiled code, it their main goal is help in development
<ul>
<li>some assertions are helpful to detect production errors too</li>
</ul>
</li>
<li>remember that assert is ment to be used, when dealign with critical, non-recoverable cases, it can’t be used as error-handling flow, external data validation(internal is ok, because you in control of calling methods, thus you need to change code and assert is great way of checking it)
<ul>
<li>basically assertion firing means, that smth is messed-up in code itself</li>
</ul>
</li>
<li>asserting is great way to verify contracts(postconditions and preconditions)</li>
<li>it is not recommended, but possible to assert code AND then still add error handling block around it
<ul>
<li>this way we still detect critical program state, BUT it will fail gracefully or even keep running
<ul>
<li>if assertions aren’t compiled, we won’t have any errors, but this will result is safe flow inside of a program on prod, because data is verified</li>
</ul>
</li>
<li>great for large, long standing projects OR something, that aren’t allowed to “just exit if everything is bad”</li>
</ul>
</li>
</ul>
</li>
<li>error-handling - if error is expected, you need to handle it, here is how:
<ul>
<li>return neutral value - for bad param, return some “default” value(ex: <code dir="auto">""</code>, <code dir="auto">0</code>, <code dir="auto">null</code>)</li>
<li>ignore it - for corrupted video frame it is easier to ignore it and display next in the stream, that dealing with it</li>
<li>return same value - related to previous example, if you have rapid stream of data, it might be ok to duplicate response, rather then dealing with broken frame</li>
<li>assume closes legal value - if it is appropriate, use closes legal value(if you can’t work with negative, “round” it to <code dir="auto">0</code>)
<ul>
<li>it is not always good idea to do so(statement is applicable to all other variants btw)</li>
</ul>
</li>
<li>log - used in combination with other, so we can prevent similar cases in future</li>
<li>throw/return error - if it isn’t responsibility of function, just break and notify function user about it(this may cascade, until responsible for handling won’t “catch”)
<ul>
<li>try catching as close as possible, so you can easily handle and access details</li>
<li>some centralized class can be used to handle errors, BUT it will couple all system to it, so use it with caution and do some DI to reduce coupling
<ul>
<li>logging is somewhat part of such object</li>
</ul>
</li>
<li>if you don’t have throw or return mechanisms in lang, create your own via returning custom statuses or setting them via pointers</li>
</ul>
</li>
<li>kill program - if it critical software, better to kill it, than assume smth or try to deal with error</li>
</ul>
<hr>
<ul>
<li>all in all, we have a trade-off between robustness(better some result, that nothing) and correctness(better no result, that somewhat incorrect)
<ul>
<li>it is matter of requirements(architecture in first place) to decide, what we need to embrace more in our program</li>
<li>it must be followed consistently</li>
</ul>
</li>
</ul>
</li>
<li>throw/return error (exceptions) in depth - if current part of code can’t deal with error, it can <code dir="auto">throw</code> it up the chain and hope, that someone can <code dir="auto">catch</code> and deal with it
<ul>
<li>use it wisely, otherwise, program WILL become a mess</li>
<li>some use-cases:
<ul>
<li>break program flow and notify(with propagation) higher parts, that somethings wrong</li>
</ul>
</li>
<li>when not to use:
<ul>
<li>for cases that can be handled in simpler manner
<ul>
<li>otherwise you break encapsulation and make program harder to understand
<ul>
<li>basically, now you need to know implementation of code you are using and it is bad</li>
</ul>
</li>
</ul>
</li>
<li>when something can be handled locally
<ul>
<li>no need to break encapsulation</li>
</ul>
</li>
<li>when it break interface/abstraction of routing too much
<ul>
<li>for example some low-level, implementation dependent, errors are leaked into outside</li>
<li>if you need to throw, map error into highly abstract object and work with that</li>
</ul>
</li>
</ul>
</li>
<li>advices:
<ul>
<li>include as much info, that can help solve exception, as possible
<ul>
<li>be careful from security perspective with it, it might be ok to expose some data for programers, but keep it abstract for user</li>
</ul>
</li>
<li>don’t create empty catch block
<ul>
<li>this is indicator of exception for no reason OR unhandled exception</li>
<li>it you need to, at leas comment why OR better log that smth went wrong</li>
</ul>
</li>
<li>if type system don’t allow stating that smth will throw, read the docs(or even code) and treat it appropriately</li>
<li>enforce standard of what part of code and how should manage exceptions
<ul>
<li>also some non-default ErrorObjects are possible, especially if you can throw anything
<ul>
<li>it is easier to work with and create “infrastructure” around, like logging etc</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>barricade approach - concept of dividing a program into parts, where each part will contain any error inside of it and prevent any spread into outside of it’s boundaries</p>
<ul>
<li>we state that some parts of program are responsible to work with untrusted data or any other source of error and have responsibility to validate and handle it, SO other parts can work with safe, “clean” data
<ul>
<li>this way we encapsulate any validation in one place</li>
</ul>
</li>
<li>we can have multiple layers of validation</li>
<li>validate data as close to “input” as possible</li>
<li>this way we can easily distinguish error-handling and assert use-cases
<ul>
<li>assert inside “clean” zone, otherwise handle any errors</li>
</ul>
</li>
</ul>
<p>debugging advices</p>
<ul>
<li>dev version of program can be less optimized, less safe and more exposed to user then production
<ul>
<li>if done correctly, it helps debugging a lot</li>
<li>overall, don’t fear of slowing down your dev env with some additional checks
<ul>
<li>ex: react will re-render twice in dev, so it is easier to detect re-rendering anomalies</li>
</ul>
</li>
</ul>
</li>
<li>consider spending some time to create/integrate and learn debugging tools</li>
<li>use offensive programing - technique of making your program crash, log or behave less error prone, when in dev mode
<ul>
<li>examples:
<ul>
<li>assert will kill program in dev</li>
<li>any unexpected case will kill program</li>
<li>make problem worst(allocate more memory, do double re-renders) to make it noticeable</li>
</ul>
</li>
</ul>
</li>
<li>remove debug functional as much as possible
<ul>
<li>make build system include/remove debug parts from code
<ul>
<li>can be done with:
<ul>
<li>preprocessors</li>
<li>macros</li>
<li>stubs: have two version of a function, one with functional, other - empty, so you will have minimal resource penalty on using it
<ul>
<li>great, when you can’t remove code completely, when building it</li>
</ul>
</li>
<li>smth more suitable for your lang</li>
</ul>
</li>
</ul>
</li>
<li>if possible, create several switches for different debug levels
<ul>
<li>now you can turn on/off different debug modes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>when going into prod, you mostly want your errors as silent as possible, so here advices on what should be removed on prod builds:</p>
<ul>
<li>leave any critical checks, it is better to fail, that create wrong results</li>
<li>non-critical checks could be swapped from crashes to messages, logs etc
<ul>
<li>if we can’t not crash, except save any work in progress, that user is doing and then crash</li>
</ul>
</li>
<li>some debug code can be left, so user can try to investigate OR somewhat mitigate the error</li>
<li>always attach logging/exporting errors</li>
<li>swap detailed error messages, to smth that not exposes too many details AND understandable for user
<ul>
<li>additional data can be dumped into log files</li>
</ul>
</li>
</ul> </div> <footer class="astro-3yyafb3n"> <div class="meta sl-flex astro-3yyafb3n">   </div> <div class="pagination-links astro-u2l5gyhi" dir="ltr"> <a href="/it_docs/all/cli/" rel="prev" class="astro-u2l5gyhi"> <svg aria-hidden="true" class="astro-u2l5gyhi astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1.5rem;"><path d="M17 11H9.41l3.3-3.29a1.004 1.004 0 1 0-1.42-1.42l-5 5a1 1 0 0 0-.21.33 1 1 0 0 0 0 .76 1 1 0 0 0 .21.33l5 5a1.002 1.002 0 0 0 1.639-.325 1 1 0 0 0-.219-1.095L9.41 13H17a1 1 0 0 0 0-2Z"/></svg>  <span class="astro-u2l5gyhi"> Previous <br class="astro-u2l5gyhi"> <span class="link-title astro-u2l5gyhi">CLI</span> </span> </a> <a href="/it_docs/all/code_snippets/" rel="next" class="astro-u2l5gyhi"> <svg aria-hidden="true" class="astro-u2l5gyhi astro-c6vsoqas" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1.5rem;"><path d="M17.92 11.62a1.001 1.001 0 0 0-.21-.33l-5-5a1.003 1.003 0 1 0-1.42 1.42l3.3 3.29H7a1 1 0 0 0 0 2h7.59l-3.3 3.29a1.002 1.002 0 0 0 .325 1.639 1 1 0 0 0 1.095-.219l5-5a1 1 0 0 0 .21-.33 1 1 0 0 0 0-.76Z"/></svg>  <span class="astro-u2l5gyhi"> Next <br class="astro-u2l5gyhi"> <span class="link-title astro-u2l5gyhi">Code_Snippets</span> </span> </a> </div>  </footer>  </div> </div>   </main> </div> </div>  </div> </div>  </body></html>